# Configuration for KataGo C++ GTP engine

# Run the program using: `./katago.exe gtp`

# --------------------------------------------------------------------------- 
# Running on an online server or in a real tournament or match
# --------------------------------------------------------------------------- 
# If you plan to run online or in a tournament, read through the "Rules"
# section below for proper handling of komi, handicaps, end-of-game cleanup,
# and other details.

# --------------------------------------------------------------------------- 
# Notes about performance and memory usage
# --------------------------------------------------------------------------- 
# For multi-GPU systems, read "OpenCL GPU settings" or "CUDA GPU settings".
#
# When using OpenCL, verify that KataGo picks the correct device! Some systems
# may have both an Intel CPU OpenCL and GPU OpenCL. If # KataGo picks the wrong
# one, correct this by specifying "openclGpuToUse".
#
# Consider adjusting "maxVisits", "ponderingEnabled", "resignThreshold", and
# other parameters depending on your intended usage.

# --------------------------------------------------------------------------- 
# Command-line usage
# --------------------------------------------------------------------------- 
# All of the below values may be set or overridden via command-line arguments:
#
# -override-config KEY=VALUE,KEY=VALUE,...

# --------------------------------------------------------------------------- 
# Logs and files
# --------------------------------------------------------------------------- 
# This section defines where and what logging information is produced.

# Each run of KataGo will log to a separate file in this dir
logDir = gtp_logs

# Use this instead of logDir to also write separate dated subdirs
# logDirDated = gtp_logs

# Use this instead of logDir to just specify a single file directly
# logFile = gtp.log

# Logging options
logAllGTPCommunication = true
logSearchInfo = true
logToStderr = false

# KataGo will display some info to stderr on GTP startup
# Uncomment the next line to suppress that and remain silent
# Default: false
# startupPrintMessageToStderr = false

# Write information to stderr, for use in things like malkovich chat to OGS.
# Default: true
# ogsChatToStderr = true

# Override where openCLTuner files and other cached data is written.
# homeDataDir = DIRECTORY

# --------------------------------------------------------------------------- 
# Analysis
# --------------------------------------------------------------------------- 
# This section configures analyis settings.
#
# Configure the maximum length of analysis printed out by lz-analyze and
# other places. This controls the number of moves after the first move in
# a variation.
#
# Default: 15
# analysisPVLen = 15

# Report winrates for chat and analysis as (BLACK|WHITE|SIDETOMOVE).
# Default: SIDETOMOVE, which is what tools that use LZ probably also expect
# reportAnalysisWinratesAs = SIDETOMOVE

# Larger values will explore the top move(s) less deeply and accurately,
# but explore and give evaluations to a greater variety of moves, for analysis
# (does not affect play).
# An extreme value like 1 distributes playouts across every move on the board,
# even very bad moves.
#
# Default: 0.04
# analysisWideRootNoise = 0.04

# --------------------------------------------------------------------------- 
# Gameplay rules
# --------------------------------------------------------------------------- 
# This section configures the scoring and playing rules. Rules can be
# changed mid-run by issuing custom GTP commands.
#
# See https://lightvector.github.io/KataGo/rules.html for rules details.
#
# See https://github.com/lightvector/KataGo/blob/master/docs/GTP_Extensions.md
# for GTP commands.

# Legal values include:
#
#   chinese, japanese, korean, aga, chinese-ogs, and new-zealand.
#
# Any particular rule set isn't exactly matched, but KataGo tries to honour
# the rules it has implemented.
rules = tromp-taylor

# An arbitrary combination of individual rules can also be specified using
# the options that follow.

# Is multiple-stone suicide legal? (Single-stone suicide is always illegal).
#
# Default: true
# multiStoneSuicideLegal = true

# Set to true when area scoring to award 0.5 points to the first pass.
#
# Default: false
# hasButton = false

# Set to false for computer rulesets that require capturing all stones
# before passing.
#
# Default: true
# friendlyPassOk = true

# Uncomment and change to adjust what board size KataGo uses upon startup
# by default if GTP doesn't specify.
#
# Default: 19
# defaultBoardSize = 19

# Specify this to force a particular komi, even if the GUI or GTP
# controller tries to set a different one
#
# Default: 7
# ignoreGTPAndForceKomi = 7

# Ko settings
# ------------------------------ 
# Simple ko rules (triple ko means no result)
# koRule = SIMPLE

# Positional superko
# koRule = POSITIONAL

# Situational superko
# koRule = SITUATIONAL

# Scoring settings
# ------------------------------ 
# Area
# scoringRule = AREA

# Territory (uses a computer-friendly territory ruleset)
# scoringRule = TERRITORY

# All surrounded empty points are scored
# taxRule = NONE

# Eyes in seki do NOT count as points
# taxRule = SEKI

# All groups are taxed up to 2 points for the two eyes needed to live
# taxRule = ALL

# Handicap game settings
# ------------------------------ 
# White receives no compensation for black's handicap stones
# (Tromp-taylor, NZ, JP)
# whiteHandicapBonus = 0

# White receives N-1 points for black's handicap stones (AGA)
# whiteHandicapBonus = N-1

# White reeives N points for black's handicap stones (Chinese)
# whiteHandicapBonus = N

# --------------------------------------------------------------------------- 
# Bot behavior
# --------------------------------------------------------------------------- 

# Resignation
# ------------------------------ 

# Resignation occurs if for at least resignConsecTurns in a row, the
# winLossUtility (on a [-1,1] scale) is below resignThreshold.
allowResignation = true
resignThreshold = -0.90
resignConsecTurns = 3

# Uncomment to not resign close games, behind by fewer than this many points.
# resignMinScoreDifference = 10

# Handicap
# ------------------------------ 
# Assume that if black makes many moves in a row right at the start of the
# game, then the game is a handicap game. This is necessary on some servers
# and for some GUIs and also when initializing from many SGF files, which may
# set up a handicap game using repeated GTP "play" commands for black rather
# than GTP "place_free_handicap" commands; however, it may also lead to
# incorrect understanding of komi if whiteHandicapBonus is used and a server
# does not have such a practice. Uncomment and set to false to disable.
#
# Default: true
# assumeMultipleStartingBlackMovesAreHandicap = true

# Makes katago dynamically adjust in handicap or altered-komi games to assume
# based on those game settings that it must be stronger or weaker than the
# opponent and to play accordingly. Greatly improves handicap strength by
# biasing winrates and scores to favor appropriate safe/aggressive play.
# Does not affect analysis (lz-analyze, kata-analyze, used by programs like
# Lizzie) so analysis remains unbiased. Uncomment and set this to 0 to disable
# this and make KataGo play the same always.
#
# Default: 0.045
# dynamicPlayoutDoublingAdvantageCapPerOppLead = 0.045

# Instead of a dynamic level, you can uncomment this and set this to a value
# from -3.0 to 3.0 to set KataGo's aggression to a FIXED level. This affects
# analysis tools (lz-analyze, kata-analyze, used by programs like Lizzie).
# Negative makes KataGo behave as if it is much weaker than the opponent,
# preferring to play defensively. Positive makes KataGo behave as if it is
# much stronger than the opponent, prefering to play aggressively or even
# overplay slightly.
#
# If this and "dynamicPlayoutDoublingAdvantageCapPerOppLead" are both set
# then dynamic will be used for all games and this fixed value will be used
# for analysis tools.
#
# Default: 0.0
# playoutDoublingAdvantage = 0.0

# Uncomment to enforce that the fixed playoutDoublingAdvantage will only
# apply when KataGo plays the specified color and will be negated when
# playing the opposite color.
# playoutDoublingAdvantagePla = BLACK
# playoutDoublingAdvantagePla = WHITE

# Passing and cleanup
# ------------------------------ 
# Make the bot never assume that its pass will end the game, even if passing
# would end and "win" under Tromp-Taylor rules. Usually this is a good idea
# when using it for analysis or playing on servers where scoring may be
# implemented non-tromp-taylorly. Uncomment and set to false to disable.
#
# Default: true
# conservativePass = true

# When using territory scoring, self-play games continue beyond two passes
# with special cleanup rules that may be confusing for human players. This
# option prevents the special cleanup phases from being reachable when using
# the bot for GTP play. Uncomment and set to false to enable entering special
# cleanup. For example, if you are testing it against itself, or against
# another bot that has precisely implemented the rules documented at
# https://lightvector.github.io/KataGo/rules.html
#
# Default: true
# preventCleanupPhase = true

# Miscellaneous behavior
# ------------------------------ 
# If the board is symmetric, search only one copy of each equivalent move.
# Attempts to also account for ko/superko, will not theoretically perfect for
# superko. Uncomment and set to false to disable.
#
# Default: true
# rootSymmetryPruning = true

# Uncomment and set to true to avoid a particular joseki that networks
# misevaluate, and also to improve opening diversity versus some particular
# other bots that like to play it all the time.
#
# Default: false
# avoidMYTDaggerHack = false

# Prefer to avoid playing the same joseki in every corner of the board.
# Uncomment to set to a specific value. See "Avoid SGF patterns".
#
# Default: 0 (even games), 0.005 (handicap games)
# avoidRepeatedPatternUtility = 0.0

# Experimental logic to fight against mirror Go even with unfavorable komi.
# Enabled by default for GTP play, disabled for GTP analysis (i.e., Lizzie)
# and analysis engine. Uncomment and set to true to enable for analysis, or
# false to disable.
#
# Default: true
# antiMirror = true

# --------------------------------------------------------------------------- 
# Search limits
# --------------------------------------------------------------------------- 
# For all of "maxVisits", "maxPlayouts", "maxTime", search will still try
# to follow GTP time controls and may make a move faster than the specified
# maximum if GTP tells it that it is playing under a clock as well in the
# current game.

# If provided, limit maximum number of root visits per search to this much.
# (With tree reuse, visits do count earlier search.)
#
# Default: 500
maxVisits = 500

# If provided, limit maximum number of new playouts per search to this much.
# (With tree reuse, playouts do not count earlier search.)
#
# Default: 300
# maxPlayouts = 300

# If provided, stop search time after this many seconds.
#
# Default: 10
# maxTime = 10

# Ponder on the opponent's turn?
ponderingEnabled = false

# Maximum time to ponder, in seconds. Comment out to make unlimited.
maxTimePondering = 60

# Note: you can set "maxVisitsPondering" or "maxPlayoutsPondering" too.

# Approx number of seconds to buffer for lag for GTP time controls - will
# move a bit faster assuming there is this much lag per move.
lagBuffer = 1.0

# The number of threads to use when searching. Powerful GPUs can be much
# higher than the number of processor cores because many threads are needed
# to feed sufficiently large batches to make good GPU usage.
#
# Run "./katago benchmark" to tune this parameter and test the effect
# of changes to any of other parameters.
numSearchThreads = 6

# Play a little faster if the opponent is passing, for friendliness
searchFactorAfterOnePass = 0.50
searchFactorAfterTwoPass = 0.25

# Play a little faster if super-winning, for friendliness
searchFactorWhenWinning = 0.40
searchFactorWhenWinningThreshold = 0.95

# --------------------------------------------------------------------------- 
# GPU settings
# --------------------------------------------------------------------------- 
# This section configures GPU settings.
#
# Maximum number of positions to send to a single GPU at once. The default
# value is roughly equal to numSearchThreads, but can be specified manually
# if running out of memory, or using multiple GPUs that expect to share work.
# nnMaxBatchSize = <integer>

# Controls the neural network cache size, which is the primary RAM/memory use.
# Increase this to improve performance for searches with tens of thousands
# of visits or more. Decrease this to limit memory usage.
#
# If you're happy to do some math - each neural net entry takes a very
# approximate 1.5KB, except when using whole-board ownership/territory
# visualizations, each entry will take a very approximate 3KB. The number of
# entries is (2 ** nnCacheSizePowerOfTwo). (2 ** 18 = 262144.)
# Cache up to (2 ** this) many neural net evaluations in case of
# transpositions in the tree. Uncomment and change want to adjust a major
# factor in KataGo's RAM usage.
# nnCacheSizePowerOfTwo = 20

# Size of mutex pool for nnCache is (2 ** this).
# nnMutexPoolSizePowerOfTwo = 16

# Randomize board orientation when running neural net evals? Uncomment and
# set to false to disable.
# nnRandomize = true

# If provided, force usage of a specific seed for nnRandomize instead of
# randomizing.
# nnRandSeed = abcdefg

# Multiple GPUs
# ------------------------------ 
# Set this to the number of GPUs to use or are available.
# Note: If more than 1, uncomment the appropriate CUDA or OpenCL section.
# numNNServerThreadsPerModel = 1

# TENSORRT GPU settings
# ------------------------------ 
# These only apply when using the TENSORRT version of KataGo.

# For one GPU: optionally uncomment this option and change if the GPU to
# use is not device 0.
# trtDeviceToUse = 0

# For two GPUs: Uncomment these options and set numNNServerThreadsPerModel.
# Change this if the first GPU you want to use turns out to be not device 0
# trtDeviceToUseThread0 = 0
# Change this if the second GPU you want to use turns out to be not device 1
# trtDeviceToUseThread1 = 1

# For three GPUs: Uncomment these options and set numNNServerThreadsPerModel.
# Change this if the first GPU you want to use turns out to be not device 0
# trtDeviceToUseThread0 = 0
# Change this if the second GPU you want to use turns out to be not device 1
# trtDeviceToUseThread1 = 1
# Change this if the third GPU you want to use turns out to be not device 2
# trtDeviceToUseThread2 = 2

# The pattern continues for additional GPUs.

# CUDA GPU settings
# ------------------------------ 
# These only apply when using the CUDA version of KataGo.

# For one GPU: optionally uncomment and change this if the GPU you want to use turns out to be not device 0
# cudaDeviceToUse = 0

# For two GPUs: Uncomment these two lines (AND set numNNServerThreadsPerModel above):
# cudaDeviceToUseThread0 = 0  # change this if the first GPU you want to use turns out to be not device 0
# cudaDeviceToUseThread1 = 1  # change this if the second GPU you want to use turns out to be not device 1

# For three GPUs: Uncomment these three lines (AND set numNNServerThreadsPerModel above):
# cudaDeviceToUseThread0 = 0  # change this if the first GPU you want to use turns out to be not device 0
# cudaDeviceToUseThread1 = 1  # change this if the second GPU you want to use turns out to be not device 1
# cudaDeviceToUseThread2 = 2  # change this if the third GPU you want to use turns out to be not device 2

# The pattern continues for additional GPUs.

# KataGo will automatically use FP16 or not based on the compute capability
# of your NVIDIA GPU. If you want to try to force a particular behavior
# though you can uncomment these lines and change them to "true" or "false".
# E.g., it's using FP16 but on your card that's giving an error, or it's not
#  using FP16 but you think it should.
# cudaUseFP16 = auto
# cudaUseNHWC = auto

# OpenCL GPU settings
# ------------------------------ 
# These only apply when using the OpenCL version of KataGo.

# Uncomment to tune OpenCL for every board size separately, rather than only the largest possible size
# openclReTunePerBoardSize = true

# For one GPU: optionally uncomment and change this if the best device to use is guessed incorrectly.
# The default behavior tries to guess the 'best' GPU or device on your system to use, usually it will be a good guess.
# openclDeviceToUse = 0

# For two GPUs: Uncomment these two lines and replace X and Y with the device ids of the devices you want to use.
# It might NOT be 0 and 1, some computers will have many OpenCL devices. You can see what the devices are when
# KataGo starts up - it should print or log all the devices it finds.
# (AND also set numNNServerThreadsPerModel above)
# openclDeviceToUseThread0 = X
# openclDeviceToUseThread1 = Y

# For three GPUs: Uncomment these three lines and replace X and Y and Z with the device ids of the devices you want to use.
# It might NOT be 0 and 1 and 2, some computers will have many OpenCL devices. You can see what the devices are when
# KataGo starts up - it should print or log all the devices it finds.
# (AND also set numNNServerThreadsPerModel above)
# openclDeviceToUseThread0 = X
# openclDeviceToUseThread1 = Y
# openclDeviceToUseThread2 = Z

# The pattern continues for additional GPUs.

# KataGo will automatically use FP16 or not based on testing your GPU during
# tuning. If you want to try to force a particular behavior though you can
# uncomment this option and change it to "true" or "false". This is a fairly
# blunt setting - more detailed settings are testable by rerunning the tuner
# with various arguments.
# openclUseFP16 = auto

# Eigen-specific settings
# ------------------------------ 
# These only apply when using the Eigen (pure CPU) version of KataGo.

# Number of CPU threads for evaluating the neural net on the Eigen backend.
#
# Default: numSearchThreads
# numEigenThreadsPerModel = X

# --------------------------------------------------------------------------- 
# Root move selection and biases
# --------------------------------------------------------------------------- 
# Uncomment and edit any of the below values to change them from their default.

# If provided, force usage of a specific seed for various things in
# the search instead of randomizing
# searchRandSeed = hijklmn

# Temperature for the early game, randomize between chosen moves with
# this temperature
# chosenMoveTemperatureEarly = 0.5

# Decay temperature for the early game by 0.5 every this many moves,
# scaled with board size.
# chosenMoveTemperatureHalflife = 19

# At the end of search after the early game, randomize between chosen
# moves with this temperature
# chosenMoveTemperature = 0.10

# Subtract this many visits from each move prior to applying
# chosenMoveTemperature (unless all moves have too few visits) to downweight
# unlikely moves
# chosenMoveSubtract = 0

# The same as chosenMoveSubtract but only prunes moves that fall below
# the threshold. This setting does not affect chosenMoveSubtract.
# chosenMovePrune = 1

# Number of symmetries to sample (without replacement) and average at the root
# rootNumSymmetriesToSample = 1

# Using LCB for move selection?
# useLcbForSelection = true

# How many stdevs a move needs to be better than another for LCB selection
# lcbStdevs = 5.0

# Only use LCB override when a move has this proportion of visits as the
# top move.
# minVisitPropForLCB = 0.15

# --------------------------------------------------------------------------- 
# Internal params
# --------------------------------------------------------------------------- 
# Uncomment and edit any of the below values to change them from their default.

# Scales the utility of winning/losing
# winLossUtilityFactor = 1.0

# Scales the utility for trying to maximize score
# staticScoreUtilityFactor = 0.10
# dynamicScoreUtilityFactor = 0.30

# Adjust dynamic score center this proportion of the way towards zero,
# capped at a reasonable amount.
# dynamicScoreCenterZeroWeight = 0.20
# dynamicScoreCenterScale = 0.75

# The utility of getting a "no result" due to triple ko or other long cycle
# in non-superko rulesets (-1 to 1)
# noResultUtilityForWhite = 0.0

# The number of wins that a draw counts as, for white. (0 to 1)
# drawEquivalentWinsForWhite = 0.5

# Exploration constant for mcts
# cpuctExploration = 1.0
# cpuctExplorationLog = 0.45

# Parameters that control exploring more in volatile positions, exploring
# less in stable positions.
# cpuctUtilityStdevPrior = 0.40
# cpuctUtilityStdevPriorWeight = 2.0
# cpuctUtilityStdevScale = 0.85

# FPU reduction constant for mcts
# fpuReductionMax = 0.2
# rootFpuReductionMax = 0.1
# fpuParentWeightByVisitedPolicy = true

# Parameters that control weighting of evals based on the net's own
# self-reported uncertainty.
# useUncertainty = true
# uncertaintyExponent = 1.0
# uncertaintyCoeff = 0.25

# Amount to apply a downweighting of children with very bad values relative
# to good ones.
# valueWeightExponent = 0.25

# Slight incentive for the bot to behave human-like with regard to passing at
# the end, filling the dame, not wasting time playing in its own territory,
# etc., and not play moves that are equivalent in terms of points but a bit
# more unfriendly to humans.
# rootEndingBonusPoints = 0.5

# Make the bot prune useless moves that are just prolonging the game to
# avoid losing yet.
# rootPruneUselessMoves = true

# Apply bias correction based on local pattern keys
# subtreeValueBiasFactor = 0.45
# subtreeValueBiasWeightExponent = 0.85

# Use graph search rather than tree search - identify and share search for
# transpositions.
# useGraphSearch = true

# How much to shard the node table for search synchronization
# nodeTableShardsPowerOfTwo = 16

# How many virtual losses to add when a thread descends through a node
# numVirtualLossesPerThread = 1

# Improve the quality of evals under heavy multithreading
# useNoisePruning = true

# --------------------------------------------------------------------------- 
# Avoid SGF patterns
# --------------------------------------------------------------------------- 
# The parameters in this section provide a way to avoid moves that follow
# specific patterns based on a set of SGF files loaded upon startup.
# Uncomment them to use this feature. Additionally, if the SGF file
# contains the string %SKIP% in a comment on a move, that move will be
# ignored for this purpose.

# Load SGF files from this directory when the engine is started
# (only on startup, will not reload unless engine is restarted)
# avoidSgfPatternDirs = path/to/directory/with/sgfs/

# Penalize this much utility per matching move.
# Set this negative if you instead want to favor SGF patterns instead of
# penalizing them. This number does not need to be large, even 0.001 will
# make a difference. Values that are too large may lead to bad play.
# avoidSgfPatternUtility = 0.001

# Optional - load only the newest this many files
# avoidSgfPatternMaxFiles = 20

# Optional - Penalty is multiplied by this per each older SGF file, so that
# old SGF files matter less than newer ones.
# avoidSgfPatternLambda = 0.90

# Optional - pay attention only to moves made by players with this name.
# For example, set it to the name that your bot's past games will show up
# as in the SGF, so that the bot will only avoid repeating moves that itself
# made in past games, not the moves that its opponents made.
# avoidSgfPatternAllowedNames = my-ogs-bot-name1,my-ogs-bot-name2

# Optional - Ignore moves in SGF files that occurred before this turn number.
# avoidSgfPatternMinTurnNumber = 0

# For more avoid patterns:
# You can also specify a second set of parameters, and a third, fourth,
# etc. by numbering 2,3,4,...
#
# avoidSgf2PatternDirs = ...
# avoidSgf2PatternUtility = ...
# avoidSgf2PatternMaxFiles = ...
# avoidSgf2PatternLambda = ...
# avoidSgf2PatternAllowedNames = ...
# avoidSgf2PatternMinTurnNumber = ...

